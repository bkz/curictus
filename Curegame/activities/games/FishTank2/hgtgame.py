##############################################################################
#
# Copyright (c) 2006-2011 Curictus AB.
#
# This file part of Curictus VRS.
#
# Curictus VRS is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# Curictus VRS is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# Curictus VRS; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#
##############################################################################

import hgt
import hgt.game
import hgt.gameutils

from hgt.event import Event
from hgt.gameelements import Sound
from hgt.gamemath import DEG2RAD
from hgt.listeners import MFBoolListener
from hgt.locale import translate as _
from hgt.nodes import X3DFileNode, hgn
from hgt.widgets.grabber import Grabber
from hgt.widgets.pushbutton import PushButton

import math
import random
import space # space.py generated by Blender exporter

from H3DUtils import *

SPACE_TILT = 65.0
MUSIC_BPM = 80.0

###########################################################################
# FishTank2 TODO: REFACTOR, CUTNPASTE SUNDAY EVENING
###########################################################################

class Game(hgt.game.Game):
    def build(self):
        random.seed()

        cfg = self.load_config()
        self.level = cfg.settings["fishtank2_level"]

        if self.level == 1:
            self.fish_count = 10
            self.fish_speed = 0.5
            self.enemy_speed = 0.1
            self.bucket_switching = False

        elif self.level == 2:
            self.fish_count = 10
            self.fish_speed = 1
            self.enemy_speed = 0.3
            self.bucket_switching = False

        elif self.level == 3:
            self.fish_count = 10
            self.fish_speed = 2
            self.enemy_speed = 0.8
            self.bucket_switching = True

        # hgt world
        hgt.world.stereoInfo.focalDistance = 0.5
        hgt.world.tilt(-SPACE_TILT)
        #hgt.world.load_stylus('ball')
        hgt.world.load_stylus('fish_net')

        # Load Blender scene
        self.add_child(space.world)

        # Grabber
        self.grabber = Grabber()
        self.grabber.correct_tilt(tilt=SPACE_TILT)

        self.number_of_enemies = 3

        self.build_final_score_grower()
        self.build_enemy_flashers()
        self.build_world()
        self.build_sounds()
        self.build_feedback_label()
        self.build_feedback_label2()
        self.build_glass_flasher()

        self.tilt_matrix = Rotation(1, 0, 0, SPACE_TILT * DEG2RAD)

    # Initialization
    def start(self):
        self.start_time = hgt.time.now
        self.above_surface = False
        self.grabbed_fish_info = None
        self.falling_fish = []
        self.touchable_enemies = True
        self.shock_the_player = False
        self.current_force = Vec3f(0, 0, 0)
        self.game_ending = False
        self.drop_in_left_bucket = True
        self.last_fish_drop_time = None

        space.nodes["ToggleGroup_FishBox"].graphicsOn = False
        space.nodes["ToggleGroup_Dropbox"].graphicsOn = False
        space.nodes["ToggleGroup_Dropbox2"].graphicsOn = False
        space.nodes["ToggleGroup_InnerAquariumGlass"].graphicsOn = False

        if self.level < 3:
            space.nodes["ToggleGroup_GuideArrow"].graphicsOn = False
            space.nodes["Appearance_RightBucket"].material = self.left_bucket_material.h3dNode

        space.nodes["Text_Level"].string = [_('Level') + ': ' + [_('Easy'), _('Medium'), _('Hard')][self.level - 1]]

        self.score = 0
        space.nodes["Text_Score"].string = [_("Score") + ":", "%d" % self.score]

        if self.level == 3:
            hgt.time.add_timeout(2.0, self.music_sound.play)

    # Updates
    def update(self):
        if self.game_ending:
            intensity = self.music_sound.sounds[0].intensity
            self.music_sound.sounds[0].intensity = intensity * 0.97

        self.grabber.update()

        # Shock if enemy has been touched
        if self.shock_the_player:
            f = Vec3f(math.sin(hgt.time.now * 90) * 2, 0, 0)
            self.force_field.force = self.current_force + f
        else:
            self.force_field.force = self.current_force

        # Update enemy positions
        since_start = hgt.time.now - self.start_time
        if since_start < 2.0:
            z_scale = 0.0
        elif since_start < 4.0:
            z_scale = (since_start - 2.0) / 2.0
        else:
            z_scale = 1

        for i in range(self.number_of_enemies):
            speed = self.enemy_speed
            offset = i * 2
            x = math.sin((hgt.time.now * speed) + offset) * 0.12
            y = math.sin((hgt.time.now * speed * 2) + offset) * 0.05 - 0.03

            # Bob up'n down in time with the music (well, almost)
            enemy_z = -0.05
            if self.level == 3:
                z = enemy_z + math.sin(hgt.time.now * 2 * math.pi * (MUSIC_BPM / 60.0)) * 0.005 * (self.level - 1) * z_scale
                t = space.nodes["Transform_GuideArrow"].translation
                space.nodes["Transform_GuideArrow"].translation = Vec3f(t.x, t.y, z + 0.1)
            else:
                z = enemy_z
            space.nodes["Transform_EnemyEmpty.%03d" % i].translation = Vec3f(x, y, z)

            # Make enemy expand and contract, to give some illusion of jelliness/swimming/"breathing"
            #jelliness = 0.7 + math.sin(hgt.time.now) * 0.1
            # read somewhere that exp(sin()) better simulates MacBook's sleep light...
            #jelliness = 1.0 + math.exp(math.sin(hgt.time.now)) * 0.1
            #space.nodes["Transform_EnemyEmpty.%03d" % i].scale = Vec3f(1, 1, jelliness)

            # Shadow is within enemy's transform
            t = space.nodes["Transform_EnemyShadow.%03d" % i].translation
            space.nodes["Transform_EnemyShadow.%03d" % i].translation = Vec3f(t.x, t.y, -z - 0.11)


        # Fish release
        if self.grabber.grabbing:
            x = hgt.haptics.proxyPosition.x
            p = self.tilt_matrix * hgt.haptics.proxyPosition

            if hgt.gameutils.inside_box(p, space.nodes["Transform_Dropbox"]) or \
               hgt.gameutils.inside_box(p, space.nodes["Transform_Dropbox2"]):

                self.grabber.release()
                fi = self.grabbed_fish_info

                fish_translation = fi['transform'].translation

                if x < 0.0:
                    bucket_vector = space.nodes["Transform_LeftBucket"].translation - fish_translation
                    lateral_momentum = -0.025
                else:
                    bucket_vector = space.nodes["Transform_RightBucket"].translation - fish_translation
                    lateral_momentum = 0.025

                bucket_vector.z = 0

                fi['dynamicTransform'].momentum = Vec3f(lateral_momentum, 0, 0)

                if self.level == 3:
                    fi['dynamicTransform'].force = Vec3f(0, 0, -2.5) + bucket_vector * 20
                else:
                    fi['dynamicTransform'].force = Vec3f(0, 0, -0.5) + bucket_vector * 5

                fi['releasePosition'] = fish_translation
                self.falling_fish.append(fi)
                self.grabbed_fish_info = None
                self.current_force = Vec3f(0, 0, 0)

                # TODO: clarify
                if (self.drop_in_left_bucket and x < 0.0) or (not self.drop_in_left_bucket and x > 0.0) or not self.bucket_switching:
                    score = 100
                    if self.last_fish_drop_time is not None:
                        bonus = 0
                        dt = hgt.time.now - self.last_fish_drop_time
                        if dt < 3.0:
                            bonus = int(math.floor((3.0 - dt) * 100))
                        score += bonus
                    self.increment_score(score)
                    self.show_feedback2("+%d" % score, self.tilt_matrix * hgt.haptics.proxyPosition + Vec3f(0, 0, 0.01))
                else:
                    self.buzz_sound.play()
                    if self.score >= 50:
                        self.increment_score(-50)
                        self.show_feedback2("-50", self.tilt_matrix * hgt.haptics.proxyPosition + Vec3f(0, 0, 0.01), negative=True)

                self.last_fish_drop_time = hgt.time.now
                self.whoosh_sound.play()

        # Check falling fish
        for fi in self.falling_fish:
            #m = fi['transformInfo'].accForwardMatrix
            #p = m * fi['dynamicTransform'].position
            p = fi['dynamicTransform'].position
            rp = fi['releasePosition']
            l = rp.z + p.z
            if l < -0.10:
                fi['dynamicTransform'].force = Vec3f(0, 0, 0)
                fi['dynamicTransform'].momentum = Vec3f(0, 0, 0)
                fi['dynamicTransform'].position = Vec3f(0, 0, l)
                fi['toggle'].graphicsOn = False
                self.splash_sound.play()

                self.falling_fish.remove(fi)

                self.fish_count -= 1

                if self.fish_count == 0:
                    self.game_ending = True
                    space.nodes["ToggleGroup_GuideArrow"].graphicsOn = False
                    hgt.time.add_timeout(2.0, self.end_game)
                else:
                    if self.level == 3:
                        if random.random() > 0.4:
                            self.switch_buckets()

        # Fish Swimming
        for fi in self.fish_info.values():
            if fi['swimming']:
                dt = fi['dynamicTransform']
                fid = fi['fishId']
                if fi['bumpTime'] is None:
                    if not hgt.gameutils.inside_box(dt.position, space.nodes["Transform_FishBox"]):
                        fi['bumpTime'] = hgt.time.now + 0.25 + 0.5 * random.random()
                        dt.angularMomentum = Vec3f(0, 0, random.choice([-1, 1]) * 5)
                        dt.momentum = -dt.momentum
                    else:
                        dt.angularMomentum = Vec3f(0, 0, math.pow(-1, fid) * math.cos(hgt.time.now + fid))
                        o = dt.orientation
                        v = o * Vec3f(1, 0, 0)
                        a = -((0.025 * self.fish_speed) * abs(math.cos((hgt.time.now + fid) * (1 + fid * 0.01)) + 0.01))
                        dt.momentum = a * v
                else:
                    if hgt.time.now > fi['bumpTime']:
                        fi['bumpTime'] = None

    def end_game(self):
        self.ping_sound.play()
        space.nodes["ToggleGroup_Level"].graphicsOn = False

        self.final_score_grower.startTime = hgt.time.now
        hgt.time.add_timeout(5.0, self.end_game2)

    def end_game2(self):
        self.log_score(
            level = self.level,
            score = self.score,
            duration = hgt.time.now - self.start_time,
        )
        self.quit()

    # Interactivity
    def touch_fish(self, evt):
        fishInfo = evt.info
        if not self.grabber.grabbing:
            self.grabber.grab(fishInfo['grabObject'])
            self.grabbed_fish_info = fishInfo
            fishInfo['swimming'] = False
            fishInfo['dynamicTransform'].momentum = Vec3f(0, 0, 0)
            fishInfo['dynamicTransform'].position = Vec3f(0, 0, 0)
            fishInfo['dynamicTransform'].angularMomentum = Vec3f(0, 0, 0)
            fishInfo['shadowToggle'].graphicsOn = False
            self.current_force = Vec3f(0, 0, -1.0)

    def touch_aquarium_glass(self, evt):
        self.glass_sound.play()

    def touch_outer_aquarium_glass(self, evt):
        self.glass_sound.play()
        self.glass_flasher.startTime = hgt.time.now

    def touch_enemy(self, evt):
        if self.touchable_enemies and not self.game_ending:
            evt.info['flasher'].startTime = hgt.time.now

            self.touchable_enemies = False
            self.shock_the_player = True
            hgt.time.add_timeout(1.0, self.make_enemies_touchable)
            hgt.time.add_timeout(0.25, self.stop_shocking)
            self.buzz_sound.play()

            if not self.game_ending:
                if self.score > 0:
                    self.increment_score(-50)
                    self.show_feedback("-50", self.tilt_matrix * hgt.haptics.proxyPosition + Vec3f(0, 0, 0.01))

    def make_enemies_touchable(self):
        self.touchable_enemies = True

    def stop_shocking(self):
        self.shock_the_player = False

    # Visuals
    def switch_buckets(self):
        self.drop_in_left_bucket = not self.drop_in_left_bucket

        t = space.nodes["Transform_GuideArrow"].translation
        if self.drop_in_left_bucket:
            space.nodes["Transform_GuideArrow"].translation = Vec3f(-0.2, t.y, t.z)
            space.nodes["Appearance_LeftBucket"].material = self.left_bucket_material.h3dNode
            space.nodes["Appearance_RightBucket"].material = self.right_bucket_material.h3dNode
        else:
            space.nodes["Transform_GuideArrow"].translation = Vec3f(0.2, t.y, t.z)
            space.nodes["Appearance_LeftBucket"].material = self.right_bucket_material.h3dNode
            space.nodes["Appearance_RightBucket"].material = self.left_bucket_material.h3dNode

    def increment_score(self, inc):
        self.score += inc
        if self.score < 0:
            self.score = 0
        space.nodes["Text_Score"].string = [_("Score") + ":", "%d" % self.score]

    def show_feedback(self, msg_str, pos):
        space.nodes["Transform_FeedbackLabel"].translation = pos + Vec3f(0, -0.02, 0.02)
        space.nodes["Text_FeedbackLabel"].string = [msg_str]
        self.feedback_fader.startTime = hgt.time.now

    def show_feedback2(self, msg_str, pos, negative=False):
        space.nodes["Transform_FeedbackLabel2"].translation = pos + Vec3f(0, -0.02, 0.02)
        space.nodes["Text_FeedbackLabel2"].string = [msg_str]
        if negative:
            space.nodes["Material_FeedbackLabel2"].diffuseColor = RGB(1, 0, 0)
            space.nodes["Material_FeedbackLabel2"].emissiveColor = RGB(1, 0, 0)
        else:
            space.nodes["Material_FeedbackLabel2"].diffuseColor = RGB(0, 1, 0)
            space.nodes["Material_FeedbackLabel2"].emissiveColor = RGB(0, 1, 0)

        self.feedback_fader2.startTime = hgt.time.now

    # Build
    def build_world(self):
        self.force_field = hgn.ForceField()
        self.add_child(self.force_field)

        self.left_bucket_material = space.nodes["Material_LeftBucket"]
        self.right_bucket_material = space.nodes["Material_RightBucket"]

        self.fish_texture = hgn.ImageTexture(url="textures/fish0.jpg")

        # Fish
        self.fish_info = {}
        for i in range(self.fish_count):
            fishModel = X3DFileNode("fish0.x3d")
            fishShadow = X3DFileNode("fish_shadow.hgt")

            self.add_child(fishModel)
            dynamicTransform = fishModel.find("DynamicTransform_Fish")
            dynamicTransform.orientation = Rotation(1, 0, 0, 90 * DEG2RAD)
            dynamicTransform.orientation = Rotation(0, 0, 1, random.random() * math.pi) * dynamicTransform.orientation
            transform = fishModel.find("Transform_Fish")

            fish_appearance = fishModel.find("FISH_APPEARANCE")
            fish_appearance.texture = self.fish_texture.h3dNode

            foo = 0.02
            fish_x = (i / float(self.fish_count)) * (2 * foo) - foo

            fish_z = -0.10 + i * 0.0045
            transform.translation = Vec3f(fish_x, 0, fish_z)

            toggle = fishModel.find("ToggleGroup_Fish")

            dynamicTransform.add_child(fishShadow)
            fishShadow.find("Transform_Plane").translation = Vec3f(0, -0.11 - fish_z + i * 0.001, 0)
            grabObject = self.grabber.register(
                transform=transform,
                toggle=toggle,
            )

            info = {
                'fishId': i,
                'transform': transform,
                'grabObject': grabObject,
                'dynamicTransform': dynamicTransform,
                'transformInfo': fishModel.find("TransformInfo_Fish"),
                'swimming': True,
                'bumpTime': None,
                'toggle': toggle,
                'shadowToggle': fishShadow.find("ToggleGroup_Plane"),
            }
            self.fish_info[i] = info
            evt = Event()
            evt.info = info

            bl = MFBoolListener(
                onTrue=self.touch_fish,
                callbackObject = evt,
            )
            fishModel.find("TouchSphere").h3dNode.isTouched.routeNoEvent(bl)

        # Touching the aquarium glass
        bl = MFBoolListener(
            onTrue=self.touch_aquarium_glass,
            callbackObject = evt,
        )
        space.nodes["Mesh_InnerAquariumGlass"].h3dNode.isTouched.routeNoEvent(bl)

        bl = MFBoolListener(
            onTrue=self.touch_outer_aquarium_glass,
            callbackObject = evt,
        )
        space.nodes["Mesh_OuterAquariumGlass"].h3dNode.isTouched.routeNoEvent(bl)

        # Touching the enemies
        for i in range(self.number_of_enemies):
            evt = Event()
            evt.info = {
                'flasher': self.enemy_flashers[i]
            }
            bl = MFBoolListener(
                onTrue=self.touch_enemy,
                callbackObject = evt,
            )
            space.nodes["Mesh_EnemySphere.%03d" % i].h3dNode.isTouched.routeNoEvent(bl)
            space.nodes["ToggleGroup_EnemySphere.%03d" % i].graphicsOn = False

    def build_sounds(self):
        self.splash_sound = Sound("sounds/splash.wav", copies=5, intensity=0.2)
        self.buzz_sound = Sound("sounds/buzz.wav", copies=5, intensity=0.2)
        self.whoosh_sound = Sound("sounds/whoosh.wav", copies=5, intensity=0.1)
        self.ping_sound = Sound("sounds/ping.wav", copies=5, intensity=0.2)
        self.glass_sound = Sound("sounds/glasstap.wav", copies=5, intensity=0.25)
        self.music_sound = Sound("sounds/music.ogg", copies=5, intensity=0.25, loop=True)

        # Add sound nodes to scenegraph
        for s in [
            self.splash_sound.node,
            self.buzz_sound.node,
            self.whoosh_sound.node,
            self.ping_sound.node,
            self.glass_sound.node,
            self.music_sound.node,
        ]:
            self.add_child(s)

    def build_feedback_label(self):
        # "Hide" feedback label
        space.nodes["Text_FeedbackLabel"].string = [" "]
        space.nodes["Material_FeedbackLabel"].transparency = 0.99

        # Build fading interpolator
        self.feedback_fader = ts = hgn.TimeSensor(
            cycleInterval = 1.0,
            loop = False
        )

        si = hgn.ScalarInterpolator(
            key = [0, 0.1, 1],
            keyValue = [1, 0, 1],
        )

        pi = hgn.PositionInterpolator(
            key = [0, 1],
            keyValue = [
                Vec3f(1, 1, 1),
                Vec3f(1, 1, 1) * 1.5,
            ],
        )

        self.add_child(ts)
        self.add_child(si)
        self.add_child(pi)

        ts.h3dNode.fraction_changed.route(
            si.h3dNode.set_fraction
        )
        si.h3dNode.value_changed.routeNoEvent(
            space.nodes["Material_FeedbackLabel"].h3dNode.transparency
        )

        ts.h3dNode.fraction_changed.route(
            pi.h3dNode.set_fraction
        )
        pi.h3dNode.value_changed.routeNoEvent(
            space.nodes["Transform_FeedbackLabel"].h3dNode.scale
        )

    def build_feedback_label2(self):
        # "Hide" feedback label
        space.nodes["Text_FeedbackLabel2"].string = [" "]
        space.nodes["Material_FeedbackLabel2"].transparency = 0.99

        # Build fading interpolator
        self.feedback_fader2 = ts = hgn.TimeSensor(
            cycleInterval = 1.0,
            loop = False
        )

        si = hgn.ScalarInterpolator(
            key = [0, 0.1, 1],
            keyValue = [1, 0, 1],
        )

        pi = hgn.PositionInterpolator(
            key = [0, 1],
            keyValue = [
                Vec3f(1, 1, 1),
                Vec3f(1, 1, 1) * 1.5,
            ],
        )

        self.add_child(ts)
        self.add_child(si)
        self.add_child(pi)

        ts.h3dNode.fraction_changed.route(
            si.h3dNode.set_fraction
        )
        si.h3dNode.value_changed.routeNoEvent(
            space.nodes["Material_FeedbackLabel2"].h3dNode.transparency
        )

        ts.h3dNode.fraction_changed.route(
            pi.h3dNode.set_fraction
        )
        pi.h3dNode.value_changed.routeNoEvent(
            space.nodes["Transform_FeedbackLabel2"].h3dNode.scale
        )

    def build_final_score_grower(self):
        # Build fading interpolator
        self.final_score_grower = ts = hgn.TimeSensor(
            cycleInterval = 2.0,
            loop = False
        )

        ei = hgn.EaseInEaseOut(
            key = [0, 1],
            easeInEaseOut = [0.1, 0.9, 0.5, 0.5],
        )

        pi = hgn.PositionInterpolator(
            key = [0, 1],
            keyValue = [
                Vec3f(1, 1, 1),
                Vec3f(1, 1, 1) * 2.0,
            ],
        )

        for n in [ts, ei, pi]:
            self.add_child(n)

        ts.h3dNode.fraction_changed.route(
            ei.h3dNode.set_fraction
        )
        ei.h3dNode.modifiedFraction_changed.route(
            pi.h3dNode.set_fraction
        )
        pi.h3dNode.value_changed.routeNoEvent(
            space.nodes["Transform_Score"].h3dNode.scale
        )

    def build_enemy_flashers(self):
        self.enemy_flashers = []

        for i in range(self.number_of_enemies):
            ts = hgn.TimeSensor(
                cycleInterval = 0.5,
                loop = False
            )

            si = hgn.ScalarInterpolator(
                key = [0, 0.5, 1],
                keyValue = [0.5, 0, 0.5],
            )

            ci = hgn.ColorInterpolator(
                key = [0, 0.5, 1],
                keyValue = [
                    RGB(0, 0, 0),
                    RGB(1, 1, 1),
                    RGB(0, 0, 0),
                ]
            )

            self.add_child(ts)
            self.add_child(si)
            self.add_child(ci)

            ts.h3dNode.fraction_changed.route(
                si.h3dNode.set_fraction
            )
            si.h3dNode.value_changed.routeNoEvent(
                space.nodes["Material_Enemy.%03d" % i].h3dNode.transparency
            )

            ts.h3dNode.fraction_changed.route(
                ci.h3dNode.set_fraction
            )
            ci.h3dNode.value_changed.routeNoEvent(
                space.nodes["Material_Enemy.%03d" % i].h3dNode.emissiveColor
            )

            self.enemy_flashers.append(ts)

    def build_glass_flasher(self):
        self.glass_flasher = ts = hgn.TimeSensor(
            cycleInterval = 0.5,
            loop = False
        )

        si = hgn.ScalarInterpolator(
            key = [0, 0.5, 1],
            keyValue = [1, 0, 1],
        )

        self.add_child(ts)
        self.add_child(si)

        ts.h3dNode.fraction_changed.route(
            si.h3dNode.set_fraction
        )
        si.h3dNode.value_changed.routeNoEvent(
            space.nodes["Material_OuterGlass"].h3dNode.transparency
        )


