##############################################################################
#
# Copyright (c) 2006-2011 Curictus AB.
#
# This file part of Curictus VRS.
#
# Curictus VRS is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# Curictus VRS is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# Curictus VRS; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#
##############################################################################

import hgt
import hgt.game

from hgt.event import Event
from hgt.gameelements import Sound, LineShape
from hgt.listeners import MFBoolListener
from hgt.locale import translate as _
from hgt.nodes import X3DFileNode
from hgt.widgets.pushbutton import PushButton

from H3DUtils import Vec3f

import math
import random

import space # space.py generated by Blender exporter

NUMBER_OF_TARGETS = 25
ALPHANUMERIC_SEQUENCE = True
END_TIMEOUT = 2.0
DRAW_LINES = False

class Game(hgt.game.Game):
    def build(self):
        random.seed()

        cfg = self.load_config()

        # Setup hgt world
        hgt.world.stereoInfo.focalDistance = 0.50
        hgt.world.load_stylus('ball')

        # Load Blender scene
        self.add_child(space.world)

        self.build_world()

        # Log target positions
        for ti in self.target_infos:
            t_id = ti['target_id']
            pos = ti['original_position']
            self.log_info(
                "target_position",
                "Target %d position" % t_id,
                id = t_id,
                x = pos.x,
                y = pos.y,
                z = pos.z,
            )

    # Start & end
    def start(self):
        self.start_time = hgt.time.now
        self.sequence_index = 0
        self.errors = 0

    def end_assessment(self):
        self.log_info("assessment_vars", "Assessment variables",
            errors=self.errors,
        )

        self.log_score(
            duration = hgt.time.now - self.start_time,
        )
        self.quit()

    # Interactivity & visuals
    def touch_target(self, evt):
        ti = evt.target_info

        self.log_event("target_press", "Pressed target %d" % ti['target_id'], id = ti['target_id'])

        if not ti['done'] and not ti['touched_this_round']:
            ti['touched_this_round'] = True


            # Correct target
            if ti['target_id'] == self.sequence_index:
                ti['appearance'].material = self.correct_target_material.h3dNode
                ti['done'] = True
                self.reset_targets()
                self.correct_sound.play()

                self.log_event("target_press_correct", "Pressed correct target %d" % ti['target_id'], id = ti['target_id'])

                if DRAW_LINES and self.sequence_index > 0:
                    self.draw_line(
                        self.target_infos[self.sequence_index - 1]['original_position'],
                        self.target_infos[self.sequence_index]['original_position']
                    )

                self.sequence_index += 1
                if self.sequence_index == NUMBER_OF_TARGETS:
                    space.nodes["Text_Message"].string = [_("Thanks.")]
                    hgt.time.add_timeout(END_TIMEOUT, self.end_assessment)

            # Wrong target
            else:
                ti['appearance'].material = self.wrong_target_material.h3dNode
                self.wrong_sound.play()
                self.errors += 1
                self.log_event("target_press_incorrect", "Pressed incorrect target %d" % ti['target_id'], id = ti['target_id'])

    def reset_targets(self):
        for ti in self.target_infos:
            ti['touched_this_round'] = False
            if not ti['done']:
                ti['appearance'].material = self.default_target_material.h3dNode

    def draw_line(self, p1, p2):
        print p1, p2
        l = LineShape(width=4.0)
        l.set_points(p1, p2)
        self.add_child(l.node)

    # Build
    def build_world(self):
        # Labels
        space.nodes["Text_Message"].string = [_("Touch all targets in order (1-A-2-B ...)")]

        # Sounds
        self.correct_sound = Sound("sounds/correct.wav", copies=3, intensity=0.5)
        self.wrong_sound = Sound("sounds/wrong.wav", copies=3, intensity=0.5)

        # Gather target materials
        self.default_target_material = space.nodes["Material_DefaultTarget"]
        self.correct_target_material = space.nodes["Material_CorrectTarget"]
        self.wrong_target_material = space.nodes["Material_WrongTarget"]

        self.target_infos = []

        for i in range(NUMBER_OF_TARGETS):
            target = X3DFileNode("target.hgt")
            self.add_child(target)

            # Make the haptic part invisible
            target.find("ToggleGroup_TargetHaptic").graphicsOn = False

            # Set the label
            if ALPHANUMERIC_SEQUENCE:
                if i % 2 == 0:
                    label = str((i / 2) + 1)
                else:
                    label = chr(ord('A') + (i / 2))
            else:
                label = str(i + 1)
            target.find("Text_TargetLabel").string = [label]

            # Set outline appearance to default color (black)
            appearance = target.find("Appearance_TargetOutline")
            appearance.material = self.default_target_material.h3dNode

            # Position the target according to the corresponding
            # empty in the scene.
            transform = target.find("Transform_TargetEmpty")
            empty_transform = space.nodes["Transform_CircleEmpty.%03d" % i]
            transform.translation = empty_transform.translation

            # Create target info
            target_info = {
                'appearance': appearance,
                'done': False,
                'original_position': transform.translation,
                'target_id': i,
                'touched_this_round': False,
            }

            self.target_infos.append(target_info)

            # Bind touch
            evt = Event()
            evt.target_info = target_info

            bl = MFBoolListener(
                onTrue=self.touch_target,
                callbackObject=evt
            )

            target.find("Mesh_TargetHaptic").h3dNode.isTouched.routeNoEvent(bl)



